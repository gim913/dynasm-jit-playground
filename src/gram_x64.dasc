|.arch x64
|.section code
|.globals GLOB_
|.actionlist actions
|
|.macro saveregs
|.endmacro 
|.macro restoreregs
|.endmacro

#include "gram_bc.h"
#include <stdint.h>
#include <iostream>

#pragma pack(push, 1)
struct Instr {
	uint32_t opcode;
	uint32_t op[3]; // operands
	uint16_t statsCounter, statsIdx;
};
#pragma pack(pop)

#define GETCD(programCounter) (instructions[programCounter].opcode)
#define GETOP(idx,programCounter) (instructions[programCounter].op[idx-1])
#define STATSCNT(programCounter) (instructions[programCounter].statsCounter)
#define STATSIDX(programCounter,cnt) (instructions[programCounter].statsIdx = (uint16_t)cnt)

void dumpInstructions(Instr* instructions, int start = 0, int end = 0);

bool dynasmGenerator(Dst_DECL, Instr* instructions, size_t start, size_t end, uint64_t* machineMem, size_t maxMemAccess)
{
	dumpInstructions(instructions, start, end);

	// we WON'T try to be smart, in first pass we
	// check if all the jumps fall into start/end range
	// (it's also allowed to do jump to 'end+1')
	// if any jump is outside we won't to try to JIT that piece

	// pass 1
	size_t locGpc = start;
	size_t dest;
	while (1)
	{
		switch (GETCD(locGpc))
		{
			case Op_Zero:
			case Op_Increment:
			case Op_Transfer:
				locGpc++;
				break;
			case Op_Jump:
			case Op_Conditional_Jump:
				dest = GETOP(3, locGpc);
				if (dest < start || dest > end+1) {
					return false;
				}
				locGpc++;
				break;
		}
		if (locGpc > end) {
			break;
		}
	}

| saveregs
|
| restoreregs
| ret

	return true;
}
